'use strict';
const proximity = require('../util/proximity.js');
const stackAndCoalesce = require('@mapbox/carmen-core').stackAndCoalesce;
const bbox = require('../util/bbox.js');
const roundTo = require('../util/round-to.js');
const termops = require('../text-processing/termops');

module.exports = spatialmatch;
module.exports.rebalance = rebalance;

/**
 * spatialmatch determines whether indexes can be spatially stacked and discards indexes that cannot be stacked together
 *
 * @access public
 *
 * @param {Array} query a list of terms composing the query to Carmen
 * @param {Array} phrasematchResults for subquery permutations generated by ./lib/phrasematch
 * @param {Object} options passed in with the query
 * @param {function} callback callback called with indexes that could be spatially stacked
 */
function spatialmatch(query, phrasematchResults, options, callback) {
    if (!phrasematchResults.length) return done(null, []);

    const preparedPhrasematches = preparePhrasematches(phrasematchResults);

    const coalesceOpts = {};
    coalesceOpts.zoom = preparedPhrasematches.maxZoom;
    if (options) {
        if (options.proximity) {
            coalesceOpts.proximity = proximity.center2zxy(
                options.proximity,
                coalesceOpts.zoom
            ).slice(1);
        }

        if (options.bbox) {
            coalesceOpts.bbox = bbox.insideTile(options.bbox, preparedPhrasematches.maxZoom).slice(1);
        }
    }

    stackAndCoalesce(preparedPhrasematches.flattenedPhrasematches, coalesceOpts, done);

    function done(err, results) {
        if (err) return callback(err);
        results = results || [];
        const combined = results.map((result) => new Spatialmatch(rebalance(query, result, preparedPhrasematches.flattenedPhrasematches), preparedPhrasematches.flattenedPhrasematches));
        combined.sort(sortByRelev);

        // Ascending and Descending order here refers to being able to support
        // `address, place, region, country` and `country, region, place, address`
        // Also supports being able to return a single feature that hasn't been
        // stacked with another index
        const sets = {};
        const doneAscending = {};
        const doneDescending = {};
        const doneSingle = {};
        const filteredSpatialmatches = [];
        for (let i = 0; i < combined.length; i++) {
            const spatialmatch = combined[i];
            const covers = spatialmatch.covers;
            for (let j = 0; j < covers.length; j++) {
                const id = covers[j].tmpid;
                if (!sets[id] || sets[id].relev < covers[j].relev) {
                    sets[id] = covers[j];
                }
            }

            const tmpid = covers[0].tmpid;
            // only allow one result in each direction
            if (covers.length > 1 && covers[0].idx > covers[1].idx && !doneDescending[tmpid]) {
                doneDescending[tmpid] = true;
                filteredSpatialmatches.push(spatialmatch);
            } else if (covers.length > 1 && covers[0].idx < covers[1].idx && !doneAscending[tmpid]) {
                doneAscending[tmpid] = true;
                filteredSpatialmatches.push(spatialmatch);
            } else if (covers.length === 1 && !doneAscending[tmpid] && !doneDescending[tmpid] && !doneSingle[tmpid]) {
                doneSingle[tmpid] = true;
                filteredSpatialmatches.push(spatialmatch);
            }
        }
        return callback(null, { results: filteredSpatialmatches, sets: sets, waste: [] });
    }
}

/**
 * rebalance recalculates the relevance based on the number of tokens and number of layers that match in the result and query
 *
 * Rebalancing is done to prevent cases where the number of tokens causes the relevance to cause an index to win
 * over an index that actually has the feature
 * For example: Martin Luther King Jr. Street, Thanjavur, Tamil Nadu would return an American city
 * since Martin Luther King Jr. Street is a really long street name
 * any result that contains the street(like Martin Luther King Jr. Street, Washington, DC would automatically have a higher relevance.
 *
 * @param {Array} query a list of terms composing the query to Carmen
 * @param {Array} stack results for a subquery combination
 * @returns {Array} - rebalanced stack
 */
function rebalance(query, stack, flattenedPhrasematches) {
    let stackMask = 0;

    for (let i = 0; i < stack.entries.length; i++) {
        stackMask |= stack.entries[i].mask;
    }
    const stackQueryCoverage = stackMask.toString(2).split(1).length - 1;
    const missingQueryTokens = query.length - stackQueryCoverage;
    const stackLength = stack.entries.length;
    const averageStackCoverage = stackQueryCoverage / stackLength;
    const entryTokenBonus = 0.01;

    let stackWeight = 1 / stackLength;
    if (missingQueryTokens > 0) {
        stackWeight = 1 / (stackLength + 1);
    }

    const stackClone = {
        mask: stackMask,
        relev: stack.relev,
        entries: []
    };

    let totalWeight = 0;
    let expectedWeight = 0;
    for (let k = 0; k < stackLength; k++) {
        const entry = stack.entries[k];
        expectedWeight += entry.grid_entry.relev;
        if (missingQueryTokens > 0) {
            const entryQueryCoverage = entry.mask.toString(2).split(1).length - 1;
            const entryTokenDifference = entryQueryCoverage - averageStackCoverage;
            const entryWeight = entryQueryCoverage / query.length;
            const entryDiscountFactor = entry.grid_entry.relev / entryWeight;
            entry.grid_entry.relev = roundTo(((entry.grid_entry.relev + 2 * stackWeight * entryDiscountFactor) / 3) + entryTokenBonus * entryTokenDifference, 8);
        }
        totalWeight += entry.grid_entry.relev;
        stackClone.entries.push(entry);
    }

    const stackPenalty = expectedWeight - stack.relev;

    stackClone.relev = Math.min(roundTo(totalWeight - stackPenalty, 8), 1);
    return stackClone;
}

function preparePhrasematches(phrasematchResults) {
    let id = 0;
    const flattened = [];
    let maxZoom = 0;

    for (let i = 0; i < phrasematchResults.length; i++) {
        for (let j = 0; j < phrasematchResults[i].length; j++) {
            const phrasematch = phrasematchResults[i][j];
            phrasematch.id = id;

            if (phrasematch.zoom > maxZoom) maxZoom = phrasematch.zoom;

            flattened[id] = phrasematch;
            id++;
        }
    }

    return {
        flattenedPhrasematches: flattened,
        maxZoom: maxZoom
    };
}

/**
 * Spatialmatch features of a stacks that could be stacked together spatially
 *
 * @constructor
 * @param {Object} cacheSpatialmatch - TODO
 * @param {Object} stackByIdx - TODO
 * @param {Object} addressDataByIdx - TODO
 * @param {Boolean} partialNumber - TODO
 */
function Spatialmatch(cacheSpatialmatch, flattenedPhrasematches) {
    this.relev = cacheSpatialmatch.relev;
    this.address = null;
    this.partialNumber = false;
    this.covers = [];
    for (let i = 0; i < cacheSpatialmatch.entries.length; i++) {
        const cacheCover = cacheSpatialmatch.entries[i];
        const phrasematch = flattenedPhrasematches[cacheCover.phrasematch_id];
        this.covers.push(new Cover(cacheCover, phrasematch));

        // just do these once, for the sake of determinism
        if (!this.address) {
            if (phrasematch.address) this.address = phrasematch.address;
        }
        if (!this.partialNumber) {
            if (phrasematch.partialNumber) this.partialNumber = phrasematch.partialNumber;
        }
    }
    this.scoredist = this.covers[0].scoredist;
    // this line artificially boosts scoredist for nearby partial-number matches
    // from address indexes, which may not have an informative score that would
    // otherwise allow them to be surfaced; the specific multiplier was determined
    // by trial and error and ideally, we'd come up with a way to tackle this in
    // a less hacky way
    if (this.partialNumber) this.scoredist *= 300;
}

/**
 * Tile Cover of a phrasematch
 *
 * @constructor
 * @param {Object} cacheCover - TODO
 * @param {Object} phrasematch - TODO
 */
function Cover(cacheCover, phrasematch) {
    this.x = cacheCover.grid_entry.x;
    this.y = cacheCover.grid_entry.y;
    this.relev = cacheCover.grid_entry.relev;
    this.id = cacheCover.grid_entry.id;
    this.idx = cacheCover.idx;
    this.tmpid = cacheCover.tmp_id;
    this.distance = cacheCover.distance;
    this.score = termops.decode3BitLogScale(cacheCover.grid_entry.score, phrasematch.scorefactor);
    this.scoredist = cacheCover.scoredist > 7 ? (phrasematch.scorefactor / 7) * cacheCover.scoredist : termops.decode3BitLogScale(cacheCover.scoredist, Math.max(phrasematch.scorefactor, 1.01));
    this.scorefactor = phrasematch.scorefactor;
    this.matches_language = cacheCover.matches_language;
    this.source_phrase_hash = cacheCover.grid_entry.source_phrase_hash;
    this.prefix = phrasematch.prefix;

    this.mask = phrasematch.mask;
    this.text = phrasematch.subquery.join(' ');
    this.zoom = phrasematch.zoom;
}

/**
 * sortByRelev spatialmatches by relevance
 *
 * @param {object} a - Spatialmatch
 * @param {object} b - Spatialmatch
 * @returns {number} sort order
 */
function sortByRelev(a, b) {
    return (b.relev - a.relev) ||
        (b.scoredist - a.scoredist) ||
        (a.covers[0].idx - b.covers[0].idx) ||
        (b.address ? 1 : 0) - (a.address ? 1 : 0);
}
